import logging
log = logging.getLogger(__name__)

from enaml.widgets.api import Action, Label, ToolBar
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

from psi.context.api import (
    BoolParameter, EnumParameter, ContextGroup, ContextRow, Parameter, Result
)
from psi.controller.api import (
    ContinuousInput, ControllerManifest, ControllerPlugin, EpochOutput,
    ExperimentAction, ExperimentEvent, ExperimentState, SimpleOutput,
    TimedTrigger, Trigger, Toggle
)
from psi.data.sinks.api import EventLog, TrialLog
from psi.experiment.api import StatusItem
from psi.data.plots import (
    EventPlot, FFTContainer, FFTChannelPlot, TimeContainer, ChannelPlot,
    ViewBox, TimeseriesPlot
)
from psi.data.sinks.api import BinaryStore

from .behavior_2afc_plugin import BehaviorPlugin, configure_stimuli, NAFCEvent


def get_status(trial, trial_state, experiment_state, side):
    # Experiment not running
    if experiment_state == 'paused':
        return 'Experiment paused'
    elif experiment_state == 'initialized':
        return 'Waiting to start'
    elif experiment_state == 'stopped':
        return 'Experiment complete'
    state = '' if trial_state is None else trial_state.value
    return 'Trial {} - {} (respond on {})'.format(trial, state, side)


def process_et(event):
    plugin = event.workbench.get_plugin('psi.controller')
    name = event.parameters['name']
    events = event.parameters['data'].events
    for _, (edge, ts) in events[['event', 'ts']].iterrows():
        plugin.et_callback(name, edge, ts)


def update_trial_log(event):
    core = event.workbench.get_plugin('enaml.workbench.core')
    core.invoke_command('trial_log.save', {'data': event.parameters['result']})


enamldef BehaviorManifest(ControllerManifest): manifest:
    '''
    Defines the core settings that any behavior experiment may require. Does
    not include timeout/reward settings as those are provided by plugins.
    '''
    factory = BehaviorPlugin

    Extension:
        id = manifest.id + '.status'
        point = 'psi.experiment.status'

        StatusItem:
            label = 'Experiment state'
            Label:
                text << get_status(
                    workbench.get_plugin('psi.controller').trial,
                    workbench.get_plugin('psi.controller').trial_state,
                    workbench.get_plugin('psi.controller').experiment_state,
                    workbench.get_plugin('psi.controller').side,
                )

    Extension:
        id = manifest.id + '.behavior_commands'
        point = 'enaml.workbench.core.commands'
        Command:
            id = 'configure_stimuli'
            handler = configure_stimuli
        Command:
            id = 'psi.controller.process_et'
            handler = process_et
        Command:
            id = 'psi.controller.update_trial_log'
            handler = update_trial_log
        Command:
            id = 'psi.controller.prepare_trial'
            handler = lambda x: controller.prepare_trial()
        Command:
            id = 'psi.controller.start_trial'
            handler = lambda x: controller.start_trial

    Extension:
        id = manifest.id + '.events'
        point = 'psi.controller.actions'

        ExperimentState:
            name = 'trial'

        ExperimentState:
            name = 'digital_reward'
        ExperimentState:
            name = 'reward'
        ExperimentState:
            name = 'iti'
        ExperimentState:
            name = 'response'
        ExperimentState:
            name = 'to'
        ExperimentEvent:
            name = 'response_duration_elapsed'

        ExperimentEvent:
            name = 'iti_duration_elapsed'
        ExperimentEvent:
            name = 'to_duration_elapsed'
        ExperimentEvent:
            name = 'deliver_reward'
        ExperimentEvent:
            name = 'trial_ready'

        ExperimentAction:
            event = 'spout_contact_1_digital_acquired'
            command = 'psi.controller.process_et'
            kwargs = {'name': 'spout_contact_1'}

        ExperimentAction:
            event = 'spout_contact_2_digital_acquired'
            command = 'psi.controller.process_et'
            kwargs = {'name': 'spout_contact_2'}

        ExperimentAction:
            event = 'np_contact_digital_acquired'
            command = 'psi.controller.process_et'
            kwargs = {'name': 'np_contact'}

        ExperimentAction:
            event = 'engines_configured'
            command = 'psi.controller.prepare_trial'

        ExperimentAction:
            event = 'engines_started'
            command = 'room_light_toggle.on'

        ExperimentAction:
            event = 'to_start'
            command = 'room_light_toggle.toggle'
            kwargs = {'state': C.lookup('keep_lights_on')}

        ExperimentAction:
            event = 'to_end'
            command = 'room_light_toggle.on'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'configure_stimuli'

        # This action is mandatory and must be executed before any other
        # commands that require some information from context. By default, an
        # infinite number of cycles are specified.
        ExperimentAction:
            event = 'experiment_initialize'
            command = 'psi.context.initialize'
            kwargs = {'selector': None}
        ExperimentAction:
            event = 'trial_end'
            command = 'psi.controller.update_trial_log'

    Extension:
        id = manifest.id + '.data'
        point = 'psi.data.sinks'
        BinaryStore:
            name = 'initiated_data'
            continuous_inputs = [
                'np_contact_analog',
                'spout_contact_1_analog',
                'spout_contact_2_analog'
            ]
        EventLog:
            show_widget = True
        TrialLog:
            show_widget = True

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        EpochOutput:
            name = 'output_1'
            label = 'Output 1'
            target_name = 'hw_ao::speaker_1'
            configurable = False

        EpochOutput:
            name = 'output_2'
            label = 'Output 2'
            target_name = 'hw_ao::speaker_2'
            configurable = False

        ContinuousInput:
            name = 'microphone'
            source_name = 'hw_ai::microphone_1'

        ContinuousInput:
            name = 'speaker_1_monitor'
            source_name = 'hw_ai::speaker_1_monitor'

        TimedTrigger:
            # This is a hardware-timed trigger that allows us to schedule a
            # trigger to occur at a very precise time (as opposed to Trigger,
            # which is software-timed and accuraccy of timing is not
            # guaranteed).
            name = 'sync_trigger'
            target_name = 'hw_do::sync_trigger'

    Extension:
        id = manifest.id + '.items'
        point = 'psi.context.items'

        ContextGroup:
            # FgBgSet generates a waveform for each trial
            # has two children: FgSet and BgSet, both of
            # which are instances of MultichannelWaveformSet
            # and are defined below
            name = 'FgBgSet'

            EnumParameter:
                name = 'combinations'
                label = 'how to combine fg and bg waveforms'
                compact_label = 'combinations'
                default = 'simple'
                choices = {'simple': "'simple'", 'all': "'all'"}
                scope = 'experiment'

            EnumParameter:
                name = 'fg_switch_channels'
                label = 'fg_switch_channels'
                compact_label = 'fg_switch_channels'
                default = 'No'
                choices = {'No': "False", 'Yes': "True"}
                scope = 'experiment'

            EnumParameter:
                name = 'bg_switch_channels'
                label = 'bg_switch_channels'
                compact_label = 'bg_switch_channels'
                default = 'No'
                choices = {'No': "False", 'same': "'same'",
                           'opposite': "'opposite'", 'combinatorial': "'combinatorial'"}
                scope = 'experiment'

            Parameter:
                name = 'fg_go_index'
                label = 'fg_go_index'
                expression = 'None'
                dtype = 'object'
                scope = 'experiment'

            Parameter:
                name = 'fg_delay'
                label = 'fg_delay'
                expression = '1.0'
                dtype = 'object'
                scope = 'experiment'

            Parameter:
                name = 'fg_snr'
                label = 'fg_snr'
                expression = '0.0'
                dtype = 'object'
                scope = 'experiment'

            Parameter:
                name = 'response_window'
                label = 'response_window'
                expression = '(0.0, 1.0)'
                dtype = 'object'
                scope = 'experiment'

            Parameter:
                name = 'random_seed'
                label = 'random_seed'
                default = 0
                dtype = 'int'
                scope = 'experiment'

        ContextGroup:
            # Instance of MultichannelWaveformSet, defines
            # foreground (target) stimuli
            name = 'Foreground wave file set'
            label = 'FgSet'

            Parameter:
                name = 'fg_path'
                label = 'folder'
                dtype = 'S'
                scope = 'experiment'

            Parameter:
                name = 'fg_level'
                label = 'level (dB peSPL)'
                dtype = 'double'
                scope = 'experiment'

            Parameter:
                name = 'fg_duration'
                label = 'duration (s)'
                default = -1
                dtype = 'double'
                scope = 'experiment'

            EnumParameter:
                name = 'fg_normalization'
                label = 'normalization'
                compact_label = 'norm'
                default = 'max'
                choices = {'max': "'pe'", 'RMS': "'rms'", 'fixed': "'fixed'"}
                scope = 'experiment'

            Parameter:
                name = 'fg_norm_fixed_scale'
                label = 'fixed norm value'
                default = 1
                dtype = 'double'
                scope = 'experiment'

            Parameter:
                name = 'fg_fit_range'
                label = 'Fit Index Range'
                expression = 'slice(None)'
                dtype = 'object'
                scope = 'experiment'

            Parameter:
                name = 'fg_fit_reps'
                label = 'Fit Reps'
                default = 1
                dtype = 'double'
                scope = 'experiment'

            Parameter:
                name = 'fg_test_range'
                label = 'Test Index Range'
                expression = 'slice(0)'
                dtype = 'object'

            Parameter:
                name = 'fg_test_reps'
                label = 'Test Reps'
                default = 1
                dtype = 'double'

            Parameter:
                name = 'fg_channel_count'
                label = 'number of channels'
                default = 1
                dtype = 'int'

            EnumParameter:
                name = 'fg_binaural_combinations'
                label = 'how to combine wavs for binaural condition'
                compact_label = 'bin_comb'
                default = 'single_offset'
                choices = {'single_offset': "'single_offset'", 'all': "'all'"}

            Parameter:
                name = 'fg_channel_offset'
                label = 'index offset between binaural stim'
                default = 1
                dtype = 'int'

            # Calibration?

        ContextGroup:
            # Instance of MultichannelWaveformSet, defines
            # background stimuli in FgBgSet
            name = 'Background wave file set'
            label = 'BgSet'

            Parameter:
                name = 'bg_path'
                label = 'folder'
                dtype = 'S'

            Parameter:
                name = 'bg_level'
                label = 'level (dB peSPL)'
                dtype = 'double'

            Parameter:
                name = 'bg_duration'
                label = 'duration (s)'
                default = -1
                dtype = 'double'

            EnumParameter:
                name = 'bg_normalization'
                label = 'normalization'
                compact_label = 'norm'
                default = 'max'
                choices = {'max': "'pe'", 'RMS': "'rms'", 'fixed': "'fixed'"}

            Parameter:
                name = 'bg_norm_fixed_scale'
                label = 'fixed norm value'
                default = 1
                dtype = 'double'

            Parameter:
                name = 'bg_fit_range'
                label = 'Fit Index Range'
                expression = 'slice(None)'
                dtype = 'object'

            Parameter:
                name = 'bg_fit_reps'
                label = 'Fit Reps'
                default = 1
                dtype = 'double'

            Parameter:
                name = 'bg_test_range'
                label = 'Test Index Range'
                expression = 'slice(0)'
                dtype = 'object'

            Parameter:
                name = 'bg_test_reps'
                label = 'Test Reps'
                default = 1
                dtype = 'double'

            Parameter:
                name = 'bg_channel_count'
                label = 'number of channels'
                default = 1
                dtype = 'int'

            EnumParameter:
                name = 'bg_binaural_combinations'
                label = 'how to combine wavs for binaural condition'
                compact_label = 'bin_comb'
                default = 'single_offset'
                choices = {'single_offset': "'single_offset'", 'all': "'all'"}

            Parameter:
                name = 'bg_channel_offset'
                label = 'index offset between binaural stim'
                default = 1
                dtype = 'int'

            # Calibration?


        ContextGroup:
            name = 'trial'
            label = 'Trial'

            BoolParameter:
                name = 'repeat_incorrect'
                label = 'Repeat incorrect/invalid trials?'
                default = True
            Parameter:
                name = 'snr'
                label = 'SNR (dB)'
                default = 10
            Parameter:
                name = 'iti_duration'
                label = 'Intertrial interval (s)'
                compact_label = 'ITI'
                default = 0.1
            Parameter:
                name = 'to_duration'
                label = 'Timeout duration (s)'
                compact_label = 'TO'
                default = 1.0
            Parameter:
                name = 'response_duration'
                label = 'Response duration (s)'
                compact_label = 'Resp'
                default = 3.0
            Parameter:
                name = 'target_delay'
                label = 'Target delay (s)'
                default = 0.5
            Parameter:
                name = 'hold_duration'
                label = 'Hold duration (s)'
                compact_label = 'Hold'
                default = 0.0
            BoolParameter:
                name = 'training_mode'
                label = 'Training mode'
                scope = 'arbitrary'
                default = True
            BoolParameter:
                name = 'manual_control'
                label = 'Manual control?'
                scope = 'arbitrary'
                default = False
            BoolParameter:
                name = 'keep_lights_on'
                label = 'Lights on during TO?'
                scope = 'arbitrary'
                default = False
            Parameter:
                name = 'np_duration'
                label = 'Nose poke duration (s)'
                compact_label = 'NP'
                default = 0.25

        ContextGroup:
            name = 'results'
            label = 'Trial results'

            Result:
                name = 'response'
                compact_label = 'Resp.'
                dtype = 'S32'
            Result:
                name = 'trial_type'
                compact_label = 'Type'
                dtype = 'S32'
            Result:
                name = 'score'
                dtype = 'S32'
            Result:
                name = 'correct'
                compact_label = 'C'
                dtype = 'bool'
            Result:
                name = 'response_ts'
                label = 'Response timestamp'
                compact_label = 'R|'
                dtype = 'float64'
            Result:
                name = 'trial_start'
                compact_label = 'T/'
                dtype = 'float64'
            Result:
                name = 'response_time'
                compact_label = 'Resp. time'
                dtype = 'float64'

    Extension:
        id = manifest.id + '.toolbar'
        point = 'psi.experiment.toolbar'

        ToolBar:
            Action:
                text = 'Request Remind'
                triggered ::
                    controller.request_remind()
                enabled << controller.experiment_state  == 'running'
            Action:
                text = 'Start Trial'
                triggered ::
                    controller.request_trial()
                enabled << controller.experiment_state == 'running' \
                    and controller.manual_control
            Action:
                separator = True
            Action:
                text = 'Simulate poke'
                checkable = True
                toggled ::
                    if checked:
                        controller.handle_event(NAFCEvent.digital_np_start)
                    else:
                        controller.handle_event(NAFCEvent.digital_np_end)
                enabled << controller.experiment_state not in ('initialized', 'stopped')
            Action:
                text = 'Simulate spout 1'
                checkable = True
                toggled ::
                    if checked:
                        controller.handle_event(NAFCEvent.digital_response_1_start)
                    else:
                        controller.handle_event(NAFCEvent.digital_response_1_end)
                enabled << controller.experiment_state not in ('initialized', 'stopped')
            Action:
                text = 'Simulate spout 2'
                checkable = True
                toggled ::
                    if checked:
                        controller.handle_event(NAFCEvent.digital_response_2_start)
                    else:
                        controller.handle_event(NAFCEvent.digital_response_2_end)
                enabled << controller.experiment_state not in ('initialized', 'stopped')
            Action:
                separator = True
            Action:
                text = 'Pause'
                enabled << controller.experiment_state not in ('initialized', 'stopped')
                checkable = True
                toggled ::
                    if checked:
                        log.info('Requesting pause')
                        controller.request_pause()
                    else:
                        log.info('Requesting resume')
                        controller.request_resume()
            Action:
                text = 'Random poke generator'
                checkable = True
                triggered ::
                    plugin = workbench.get_plugin(manifest.id)
                    if checked:
                        plugin.start_random_behavior()
                    else:
                        plugin.stop_random_behavior()

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'trial_plot_container'
            label = 'Trial timing'
            span = 10

            ViewBox:
                name = 'microphone'
                y_min = -1
                y_max = 1

                ChannelPlot:
                    source_name = 'microphone'
                    pen_color = 'black'

                ChannelPlot:
                    source_name = 'speaker_1_monitor'
                    pen_color = 'blue'

                #ChannelPlot:
                #    source_name = 'sync_monitor'
                #    pen_color = 'red'

            ViewBox:
                name = 'IR_sensors'
                y_min = 0
                y_max = 5

                ChannelPlot:
                    decimate_mode = 'none'
                    source_name = 'spout_contact_1'
                    pen_color = 'blue'

                ChannelPlot:
                    decimate_mode = 'none'
                    source_name = 'spout_contact_2'
                    pen_color = 'red'

                ChannelPlot:
                    decimate_mode = 'none'
                    source_name = 'np_contact_analog'
                    pen_color = 'green'

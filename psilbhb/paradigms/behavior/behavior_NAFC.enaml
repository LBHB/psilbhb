import logging
log = logging.getLogger(__name__)

import enum

from atom.api import Bool, Int, Str, Typed
from enaml.application import timed_call
from enaml.core.api import d_, Looper
from enaml.widgets.api import Action, ToolBar
from enaml.workbench.api import Extension
import numpy as np

from psi.context.api import (BoolParameter, ContextGroup, ContextRow,
                             SequenceSelector, Parameter, Result)

from psi.controller.api import (ContinuousInput, ContinuousOutput,
                                ControllerManifest, ControllerPlugin,
                                EpochOutput, ExperimentAction, ExperimentEvent,
                                ExperimentState, TimedTrigger, Trigger,
                                Toggle)

from psi.data.plots import (EventPlot, FFTContainer, FFTChannelPlot, TimeContainer,
                            ChannelPlot, ViewBox, TimeseriesPlot)
from psi.data.sinks.api import BinaryStore

#from .behavior_mixins import (BaseBehaviorPlugin, NAFCTrialScore,
#                              TrialState)
from .behavior_mixins import (BaseBehaviorPlugin, TrialState)


################################################################################
# Supporting
################################################################################
class NAFCTrialState(TrialState):
    '''
    Defines the possible states that the experiment can be in. We use an Enum to
    minimize problems that arise from typos by the programmer (e.g., they may
    accidentally set the state to "waiting_for_timeout" rather than
    "waiting_for_to").
    '''
    waiting_for_resume = 'waiting for resume'
    waiting_for_trial_start = 'waiting for trial start'
    waiting_for_hold = 'waiting for hold'
    waiting_for_response = 'waiting for response'
    waiting_for_to = 'waiting for timeout'
    waiting_for_iti = 'waiting for intertrial interval'
    waiting_for_reward_end = 'waiting for animal to break spout contact'


class NAFCResponse(enum.Enum):

    no_response = 'no_response'
    reward = 'reward'
    early_reward = 'early_reward'


class NAFCEvent(enum.Enum):
    '''
    Defines the possible events that may occur during the course of the
    experiment.
    '''
    hold_start = 'hold started'
    hold_duration_elapsed = 'hold duration elapsed'

    response_start = 'response period started'
    response_end = 'response timed out'
    response_duration_elapsed = 'response duration elapsed'

    reward_start = 'reward contact'
    reward_end = 'withdrew from reward'

    digital_reward_start = 'digital_reward_start'
    digital_reward_end = 'digital_reward_end'

    to_start = 'timeout started'
    to_end = 'timeout over'
    to_duration_elapsed = 'timeout duration elapsed'

    iti_start = 'ITI started'
    iti_end = 'ITI over'
    iti_duration_elapsed = 'ITI duration elapsed'

    trial_start = 'trial start'
    trial_end = 'trial end'


################################################################################
# Plugin
################################################################################
class BehaviorPlugin(BaseBehaviorPlugin):
    '''
    Plugin for NAFC experiments that are reward based.
    '''
    # This will control the number of alternate forced choice options (1 ...
    # N). This won't automagically work. You still need to set up the
    # experiment chamber and add the appropriate inputs and outputs as needed
    # to the IO manifest for the system. 
    NAFC = Int(2)

    # The speaker that will be used for the target.
    current_speaker = Int()

    # Used by the trial sequence selector to randomly select between the
    # outputs. The default value for this attribute is automatically
    # initialized by calling the class.
    rng = Typed(np.random.RandomState)

    manual_control = d_(Bool(), writable=False)

    next_trial_state = Str()


    def request_trial(self, trial_type):
        log.info('Requesting trial')
        self.prepare_trial(trial_type=trial_type, auto_start=True)

    def _default_trial_state(self):
        return NAFCTrialState.waiting_for_resume

    event_map = {
        ('rising', 'reward_contact'): NAFCEvent.reward_start,
        ('falling', 'reward_contact'): NAFCEvent.reward_end,
    }

    def apply_changes(self):
        if self.trial_state in (NAFCTrialState.waiting_for_trial_start,
                                NAFCTrialState.waiting_for_iti):
            self._apply_changes()
            return True
        return False

    def get_speaker(self):
        return self.rng.randint(0, self.NAFC) + 1

    def prepare_trial(self, trial_type=None, auto_start=False):
        # Figure out next trial and set up selector.
        self.trial += 1

        if self.prior_score == NAFCTrialScore.incorrect:
            # We will just re-use the last speaker and trial type used which
            # were saved in self.trial_type and self.current_speaker. Contrast
            # this with the alternate actions we can take which include
            # determining the trial type (default or remind), the speaker to
            # use, and advancing to the next setting in the correct selector.
            pass
        elif self.trial <= self.context.get_value('remind_trials'):
            self.trial_type = NAFCTrialType.remind
            self.current_speaker = self.get_speaker()
            self.context.next_setting(self.trial_type.value)
        elif self._remind_requested:
            self._remind_requested = False
            self.trial_type = NAFCTrialType.remind
            self.current_speaker = self.get_speaker()
            self.context.next_setting(self.trial_type.value)
        else:
            self.trial_type = NAFCTrialType.default
            self.current_speaker = self.get_speaker()
            self.context.next_setting(self.trial_type.value)

        self.manual_control = self.context.get_value('manual_control')
        self.trial_info = {
            'response_start': np.nan,
            'response_ts': np.nan,
            'trial_type': self.trial_type.value,
        }
        self.trial_state = NAFCTrialState.waiting_for_trial_start
        self.invoke_actions('trial_ready')
        if auto_start or not self.manual_control:
            self.start_trial()

    def start_trial(self):
        log.info('Starting next trial')
        # This is broken into a separate method to allow the toolbar to call
        # this method for training.
        ts = self.get_ts()
        self.invoke_actions(NAFCEvent.trial_start.name, ts)
        self.advance_state('hold', ts)
        self.trial_info['trial_start'] = ts

    def handle_waiting_for_hold(self, event, timestamp):
        if event in (NAFCEvent.reward_start, NAFCEvent.digital_reward_start):
            self.end_trial(NAFCResponse.early_reward, NAFCTrialScore.false_alarm)
        elif event == NAFCEvent.hold_duration_elapsed:
            log.info('Hold duration over')
            # If we are in training mode, deliver a reward preemptively
            if self.context.get_value('training_mode') and \
                    self.trial_type.value.startswith('go'):
                self.invoke_actions('deliver_reward', timestamp)
            self.advance_state('response', timestamp)
            self.trial_info['response_start'] = timestamp

    def handle_waiting_for_response(self, event, timestamp):
        if event in (NAFCEvent.reward_start, NAFCEvent.digital_reward_start):
            self.invoke_actions(NAFCEvent.response_end.name, timestamp)
            self.trial_info['response_ts'] = timestamp
            if self.trial_type.value.startswith('nogo'):
                score = NAFCTrialScore.false_alarm
            else:
                score = NAFCTrialScore.hit
                # If we are in training mode, the reward has already been
                # delivered.
                if not self.context.get_value('training_mode'):
                    self.invoke_actions('deliver_reward', timestamp)
            self.end_trial(NAFCResponse.reward, score)
        elif event == NAFCEvent.response_duration_elapsed:
            self.invoke_actions(NAFCEvent.response_end.name, timestamp)
            self.trial_info['response_ts'] = np.nan
            if self.trial_type.value.startswith('nogo'):
                score = NAFCTrialScore.correct_reject
            else:
                score = NAFCTrialScore.miss
            self.end_trial(NAFCResponse.no_response, score)

    def end_trial(self, response, score):
        self.stop_event_timer()
        ts = self.get_ts()

        self.prior_score = score
        base_trial_type = self.trial_info['trial_type'].split('_', 1)[0]

        self.consecutive_nogo = self.consecutive_nogo + 1 \
            if base_trial_type == 'nogo' else 0

        response_time = self.trial_info['response_ts']-self.trial_info['trial_start']
        self.trial_info.update({
            'response': response.value,
            'score': score.value,
            'correct': score in (NAFCTrialScore.correct_reject, NAFCTrialScore.hit),
            'response_time': response_time,
        })
        self.trial_info.update(self.context.get_values())
        self.invoke_actions('trial_end', ts, kw={'result': self.trial_info.copy()})

        if score == NAFCTrialScore.false_alarm:
            # Call timeout actions and the wait for animal to withdraw from spout
            self.invoke_actions(NAFCEvent.to_start.name, ts)
            self.start_wait_for_reward_end(ts, 'to')
        elif score == NAFCTrialScore.hit:
            # Animal will still be on the spout. Need to wait for animal to
            # withdraw.
            self.start_wait_for_reward_end(ts, 'iti')
        else:
            # This is a correct reject or a miss, which indicates the animal is
            # not on the spout. No need to wait for lick spout withdrwawal.
            self.advance_state('iti', ts)

        # Apply pending changes that way any parameters (such as repeat_FA or
        # go_probability) are reflected in determining the next trial type.
        if self._apply_requested:
            self._apply_changes(False)

    def advance_state(self, state, timestamp):
        self.trial_state = getattr(NAFCTrialState, f'waiting_for_{state}')
        action_name = getattr(NAFCEvent, f'{state}_start').name
        self.invoke_actions(action_name, timestamp)
        duration = f'{state}_duration'
        elapsed_event = getattr(NAFCEvent, f'{state}_duration_elapsed')
        self.start_event_timer(duration, elapsed_event)

    def handle_waiting_for_reward_end(self, event, timestamp):
        if event in (NAFCEvent.reward_end, NAFCEvent.digital_reward_end):
            self.advance_state(self.next_trial_state, timestamp)

    def handle_waiting_for_trial_start(self, event, timestamp):
        pass

    def start_wait_for_reward_end(self, timestamp, next_state):
        self.trial_state = NAFCTrialState.waiting_for_reward_end
        self.next_trial_state = next_state

    def handle_waiting_for_to(self, event, timestamp):
        if event == NAFCEvent.to_duration_elapsed:
            # Turn the light back on
            self.invoke_actions(NAFCEvent.to_end.name, timestamp)
            self.advance_state('iti', timestamp)
        elif event in (NAFCEvent.reward_start, NAFCEvent.digital_reward_start):
            # Animal repoked. Cancel timeout timer and wait for animal to
            # disconnect from lick spout.
            self.stop_event_timer()
            self.start_wait_for_reward_end(timestamp, 'to')

    def handle_waiting_for_iti(self, event, timestamp):
        if event in (NAFCEvent.reward_start, NAFCEvent.digital_reward_start):
            # Animal attempted to get reward. Reset ITI interval.
            self.stop_event_timer()
            self.start_wait_for_reward_end(timestamp, 'iti')
        elif event == NAFCEvent.iti_duration_elapsed:
            self.invoke_actions(NAFCEvent.iti_end.name, timestamp)
            if self._pause_requested:
                self.pause_experiment()
                self.trial_state = NAFCTrialState.waiting_for_resume
            else:
                self.prepare_trial()


################################################################################
# Manifest
################################################################################
enamldef BehaviorManifest(ControllerManifest): manifest:
    '''
    Defines the core settings that any behavior experiment may require. Does
    not include timeout/reward settings as those are provided by plugins.
    '''
    attr NAFC

    factory = lambda: BehaviorPlugin(NAFC=manifest.NAFC)

    Extension:
        id = manifest.id + '.events'
        point = 'psi.controller.actions'

        ExperimentState:
            name = 'digital_reward'
        ExperimentState:
            name = 'reward'
        ExperimentState:
            name = 'iti'
        ExperimentState:
            name = 'response'
        ExperimentState:
            name = 'to'
        ExperimentEvent:
            name = 'response_duration_elapsed'

        ExperimentEvent:
            name = 'iti_duration_elapsed'
        ExperimentEvent:
            name = 'to_duration_elapsed'
        ExperimentEvent:
            name = 'deliver_reward'
        ExperimentEvent:
            name = 'trial_ready'

        ExperimentAction:
            event = 'engines_configured'
            command = 'background.start'

        ExperimentAction:
            event = 'reward_contact_digital_acquired'
            command = 'psi.controller.process_et'
            kwargs = {'name': 'reward_contact'}

        ExperimentAction:
            event = 'engines_configured'
            command = 'psi.controller.prepare_trial'

        ExperimentAction:
            event = 'engines_started'
            command = 'room_light_toggle.on'

        ExperimentAction:
            event = 'to_start'
            command = 'room_light_toggle.off'

        ExperimentAction:
            event = 'to_start'
            command = 'background.pause'

        ExperimentAction:
            event = 'to_end'
            command = 'room_light_toggle.on'

        ExperimentAction:
            event = 'to_end'
            command = 'background.resume'

        ExperimentAction:
            event = 'experiment_paused'
            command = 'background.pause'
            kwargs = {'delay': 0.5}

        ExperimentAction:
            event = 'experiment_resumed'
            command = 'background.resume'
            kwargs = {'delay': 0.5}

        ExperimentAction:
            # The operations required to actually generate and upload the token
            # take some time, so we have to allow for a small delay that is
            # defined by the target_delay parameter.
            event = 'trial_start'
            command = 'target.start'
            kwargs = {'delay': C.lookup('target_delay')}
            weight = 0

        ExperimentAction:
            # This schedules a TTL pulse to be sent via the channel linked to
            # the sync_trigger output. The TTL pulse will start at the exact
            # same time as target_start and last for 0.5 sec. Whenever an
            # ExperimentAction is triggered, kwargs will automatically include
            # the event name (in this case, "target_start") and the timestamp
            # the event occurred (this is how the sync_trigger.trigger command
            # knows when to schedule the trigger to begin). If the event was
            # hardware-timed, then the timestamp will be accurate down to the
            # sample).
            event = 'target_start'
            command = 'sync_trigger.trigger'
            kwargs = {'duration': 0.5}

    Extension:
        id = manifest.id + '.data'
        point = 'psi.data.sinks'

        BinaryStore:
            continuous_inputs = ['reward_contact_analog']

    Extension:
        id = 'io'
        point = 'psi.controller.io'

        ContinuousInput:
            name = 'microphone'
            source_name = 'hw_ai::microphone_1'

        ContinuousInput:
            name = 'sync_monitor'
            source_name = 'hw_ai::sync_monitor'

        TimedTrigger:
            # This is a hardware-timed trigger that allows us to schedule a
            # trigger to occur at a very precise time (as opposed to Trigger,
            # which is software-timed and accuraccy of timing is not
            # guaranteed).
            name = 'sync_trigger'
            target_name = 'hw_do::sync_trigger'

    Extension:
        id = manifest.id + '.items'
        point = 'psi.context.items'

        ContextGroup:
            name = 'trial'
            label = 'Trial'

            Parameter:
                name = 'snr'
                label = 'SNR (dB)'
                default = 10
            Parameter:
                name = 'iti_duration'
                label = 'Intertrial interval (s)'
                compact_label = 'ITI'
                default = 0.1
            Parameter:
                name = 'to_duration'
                label = 'Timeout duration (s)'
                compact_label = 'TO'
                default = 1.0
            Parameter:
                name = 'response_duration'
                label = 'Response duration (s)'
                compact_label = 'Resp'
                default = 3.0
            Parameter:
                name = 'target_delay'
                label = 'Target delay (s)'
                default = 0.5
            Parameter:
                name = 'hold_duration'
                label = 'Hold duration (s)'
                compact_label = 'Hold'
                default = 0.0
            BoolParameter:
                name = 'training_mode'
                label = 'Training mode'
                scope = 'arbitrary'
                default = True
            BoolParameter:
                name = 'manual_control'
                label = 'Manual control?'
                scope = 'arbitrary'
                default = False

        ContextGroup:
            name = 'selector'
            label = 'Next value'

            BoolParameter:
                name = 'repeat_fa'
                label = 'Repeat FA?'
                compact_label = 'RFA'
                scope = 'arbitrary'
                default = True

        ContextGroup:
            name = 'results'
            label = 'Trial results'

            Result:
                name = 'response'
                compact_label = 'Resp.'
                dtype = 'S32'
            Result:
                name = 'trial_type'
                compact_label = 'Type'
                dtype = 'S32'
            Result:
                name = 'score'
                dtype = 'S32'
            Result:
                name = 'correct'
                compact_label = 'C'
                dtype = 'bool'
            Result:
                name = 'response_ts'
                label = 'Response timestamp'
                compact_label = 'R|'
                dtype = 'float64'
            Result:
                name = 'trial_start'
                compact_label = 'T/'
                dtype = 'float64'
            Result:
                name = 'response_time'
                compact_label = 'Resp. time'
                dtype = 'float64'

    Extension:
        id = 'selectors'
        point = 'psi.context.selectors'
        SequenceSelector:
            name = 'default'
            label = 'Test Sequence'
        SequenceSelector:
            name = 'remind'
            label = 'Remind Sequence'

    Extension:
        id = manifest.id + '.toolbar'
        point = 'psi.experiment.toolbar'

        ToolBar:
            Action:
                text = 'Request Remind'
                triggered ::
                    controller.request_remind()
                enabled << controller.experiment_state  == 'running'
            Looper:
                iterable = range(manifest.NAFC)
                Action:
                    # When using a Looper, you need to provide an iterable
                    # function. The iterable function will create an object
                    # called loop_item. On each "iteration" loop_item will
                    # contain the value of the next item in the iterable.
                    text = f'Start Trial {loop_item + 1}'
                    triggered ::
                        raise NotImplementedError
                        #controller.request_trial(NAFCTrialType.go_manual)
                    enabled << controller.experiment_state == 'running' \
                        and controller.manual_control
            Looper:
                iterable = range(manifest.NAFC)
                Action:
                    text = f'Simulate lick {loop_item + 1}'
                    checkable = True
                    toggled ::
                        event_base = f'digital_spout_{loop_item + 1}'
                        if checked:
                            event = getattr(NAFCEvent, f'{event_base}_start')
                        else:
                            event = getattr(NAFCEvent, f'{event_base}_end')
                        controller.handle_event(event)
                    enabled << controller.experiment_state not in ('initialized', 'stopped')
            Action:
                text = 'Pause'
                enabled << controller.experiment_state not in ('initialized', 'stopped')
                checkable = True
                toggled ::
                    if checked:
                        log.info('Requesting pause')
                        controller.request_pause()
                    else:
                        log.info('Requesting resume')
                        controller.request_resume()

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer:
            name = 'trial_plot_container'
            label = 'Trial timing'
            span = 10

            ViewBox:
                name = 'microphone'
                y_min = -1
                y_max = 1

                ChannelPlot:
                    source_name = 'microphone'
                    pen_color = 'black'

                ChannelPlot:
                    source_name = 'sync_monitor'
                    pen_color = 'red'

            ViewBox:
                name = 'reward_contact'
                y_min = 0
                y_max = 5

                ChannelPlot:
                    source_name = 'reward_contact_analog'
                    pen_color = 'blue'
